'''Метрополитен состоит из нескольких линий метро. Все станции метро в городе пронумерованы натуральными числами от 1 до N. 
На каждой линии расположено несколько станций. Если одна и та же станция расположена сразу на нескольких линиях, 
то она является станцией пересадки и на этой станции можно пересесть с любой линии, которая через нее проходит, 
на любую другую (опять же проходящую через нее).

Напишите программу, которая по данному вам описанию метрополитена определит, с каким минимальным числом пересадок можно добраться 
со станции A на станцию B. Если данный метрополитен не соединяет все линии в одну систему, то может так получиться, 
что со станции A на станцию B добраться невозможно, в этом случае ваша программа должна это определить.

Формат ввода
Сначала вводится число N — количество станций метро в городе (2≤N≤100). Далее следует число M — количество линий метро (1≤M≤20). 
Далее идет описание M линий. Описание каждой линии состоит из числа Pi — количество станций на этой линии (2≤Pi≤50) и Pi чисел, 
задающих номера станций, через которые проходит линия (ни через какую станцию линия не проходит дважды).

Затем вводятся два различных числа: A — номер начальной станции, и B — номер станции, на которую нам нужно попасть. 
При этом если через станцию A проходит несколько линий, то мы можем спуститься на любую из них. Так же если через станцию B проходит несколько линий, 
то нам не важно, по какой линии мы приедем.

Формат вывода
Выведите минимальное количество пересадок, которое нам понадобится. Если добраться со станции A на станцию B невозможно, 
программа должна вывести одно число –1 (минус один).

Пример
Ввод
5
2
4 1 2 3 4
2 5 3
3 1
Вывод
0'''


from collections import deque

queue = deque()

N = int(input())

dct = {}

M = int(input())
for i in range(1, M + 1):
    vertex = list(map(int, input().split()))
    dct[i] = set(vertex[1:])

graph = {}

for k1 in dct:
    graph[k1] = set()
    for k2 in dct:
        if k2 != k1 and dct[k1] & dct[k2] != set():
            graph[k1].add(k2)


a, b = list(map(int, input().split()))

start = []
for k in graph:
    if a in dct[k]:
        start.append(k)

dp = [None] * (M + 1)
for elem in start:
    dp[elem] = 0

queue = deque(start)

while queue:
    vertex = queue.popleft()
    for neig in graph[vertex]:
        if dp[neig] == None:
            dp[neig] = dp[vertex] + 1
            queue.append(neig)

ans = -1
for k in graph:
    if b in dct[k]:
        if dp[k] != None:
            if ans == -1:
                ans = dp[k]
            else:
                ans = min(ans, dp[k])
        
print(ans)
